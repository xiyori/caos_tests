|                      |       |
|----------------------|-------|
| **Time limit:**      | `1 s` |
| **Real time limit:** | `5 s` |
| **Memory limit:**    | `64M` |


### Problem sm06-2: c/algorithms/qsort-1

Напишите функцию:

    
    
    void process(size_t count, int *data, int *order);

В нужные места в прототипе этой функции добавьте ключевое слово
`const`.

Функция `process` получает на вход `count` целых чисел,
размещающихся в массиве `data`. Параметр `order` указывает на
область памяти (массив), достаточную для размещения `count`
значений типа `int`.

Функция `process` должна сформировать выходной массив `order`
таким образом, что элемент `order[i]` должен хранить индекс `j`
такой, что если бы массив `data` был бы отсортирован по
возрастанию в массиве `data_sorted`, то `data_sorted[i] ==
data[j]`. Массив `data` модифицироваться в результате работы
функции не должен.

Если два элемента равны, то должно сохраняться их относительное
положение. То есть индексы j равных элементов в массиве `order`
должны идти в порядке возрастания.

Например, если входной массив содержит числа:

    
    
    {5, 4, 3, 2, 1}

Массив `order` должен после работы функции быть равен:

    
    
    {4, 3, 2, 1, 0}

А если входной массив содержит числа:

    
    
    {5, 3, 3, 2, 1}

То результат работы должен быть равен:

    
    
    {4, 3, 1, 2, 0}

Для сортировки используйте функцию `qsort_r` (расширение glibc в
Linux). Можете предполагать, что ваша программа будет
компилироваться с необходимыми для ее использования опциями
препроцессора.

Функция сравнения должна использовать минимальное число операций
сравнения элементов.

Не используйте глобальные переменные и временные массивы.

Вы должны сдать только текст функции (и необходимые для ее
компиляции директивы #include). Текст не должен содержать функцию
`main`.

